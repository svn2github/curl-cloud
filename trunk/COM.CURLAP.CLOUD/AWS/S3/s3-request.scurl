
{curl-file-attributes character-encoding = "shift-jis"}

{import * from CURL.UTIL.BASE64}
{import * from S3.UTIL}
{import * from CURL.IO.HTTP}

{define-class public S3Request
  
  || HTTPリクエストヘッダーに用いるハッシュテーブル
  field public headers:HttpRequestHeaders =
      {HttpRequestHeaders.default 
        "Host", "",
        "Date", "",
        "Content-MD5", "",
        "Content-Type", ""
      }
  || x-amz headers
  field public amz-headers:{HashTable-of String, String} =
      {new {HashTable-of String, String}}
  field private default-host:String || ホスト初期値
  field private access-key-id:String
  field private secret-key-id:String
        
  || --------------------------------------------
  || コンストラクタ
  {constructor public {default access-key-id:String, secret-key-id:String, default-host:String}
    set self.access-key-id = access-key-id
    set self.secret-key-id = secret-key-id
    set self.default-host = default-host
    set self.headers["Host"] = self.default-host
  }
  
  || --------------------------------------------
  || get-bucket-list
  {method public {get-bucket-list}:#HttpByteInputStream
    
    def verb = HttpRequestMethod.get
    def bucket = null
    def key = "/"
    set self.headers["Date"] = {convert-date}
    let string-to-sign:String = {self.return-string-to-sign bucket, key, verb}    
    def signature = {self.get-signature string-to-sign}
    set self.headers["Authorization"] = "AWS " & self.access-key-id & ":" & signature
    def url = {abs-url "http://" & self.headers["Host"] & key}
    
    {return {open-http-file url, self.headers, verb}}
  }
  
  || --------------------------------------------
  || get-bucket
  {method public {get-bucket
                     bucket:#String,
                     key:String
                 }:#HttpByteInputStream
    
    def verb = HttpRequestMethod.get

    set self.headers["Date"] = {convert-date}
    let string-to-sign:String = {self.return-string-to-sign bucket, key, verb}    
    def signature = {self.get-signature string-to-sign}
    set self.headers["Authorization"] = "AWS " & self.access-key-id & ":" & signature
    
    def url = {abs-url "http://" & self.headers["Host"] & key}
    
    {return {open-http-file url, self.headers, verb}}
  }
  
  || --------------------------------------------
  || get-object
  {method public {get-object
                     bucket:String,
                     key:String
                 }:#HttpByteInputStream
    
    def verb = HttpRequestMethod.get

    set self.headers["Date"] = {convert-date}
    let string-to-sign:String = {self.return-string-to-sign bucket, key, verb}    
    def signature = {self.get-signature string-to-sign}
    set self.headers["Authorization"] = "AWS " & self.access-key-id & ":" & signature
    
    def url = {abs-url "http://" & self.headers["Host"] & key}
    
    {return {open-http-file url, self.headers, verb}}
  }
 
  || --------------------------------------------
  || put-bucket
  {method public {put-bucket
                     bucket:String,
                     acl:#String = null
                 }:#HttpByteInputStream
    
    def verb = HttpRequestMethod.put
    def key = "/"
    {if-non-null acl then
        {self.set-amz-headers "x-amz-acl", acl}
    }
    set self.headers["Date"] = {convert-date}
    let string-to-sign:String = {self.return-string-to-sign bucket, key, verb}    
    def signature = {self.get-signature string-to-sign}
    set self.headers["Authorization"] = "AWS " & self.access-key-id & ":" & signature
    
    def url = {abs-url "http://" & self.headers["Host"] & key}
    
    || HTTP接続
    {return {open-http-file url, self.headers, verb}} 
  }
  
  || --------------------------------------------
  || put-object
  {method public {put-object
                     bucket:#String,
                     key:String,
                     object:ByteArray,
                     content-type:String,
                     acl:#String = null
                 }:#HttpByteInputStream
    
    def verb = HttpRequestMethod.put      
    {if-non-null acl then
        {self.set-amz-headers "x-amz-acl", acl}
    }
    set self.headers["Content-Type"] = content-type
    set self.headers["Date"] = {convert-date}
    let string-to-sign:String = {self.return-string-to-sign bucket, key, verb}    
    def signature = {self.get-signature string-to-sign}
    set self.headers["Authorization"] = "AWS " & self.access-key-id & ":" & signature
    
    def url = {abs-url "http://" & self.headers["Host"] & key}
    
    || HTTP接続
    {return {open-http-file url, self.headers, verb, data = {HttpRequestForm.default object, content-type}}}
  }
  
  || --------------------------------------------
  || delete-bucket
  {method public {delete-bucket
                     bucket:String
                 }:#HttpByteInputStream
    
    def verb = HttpRequestMethod.delete
    def key = "/"
       
    set self.headers["Date"] = {convert-date}
    let string-to-sign:String = {self.return-string-to-sign bucket, key, verb}    
    def signature = {self.get-signature string-to-sign}
    set self.headers["Authorization"] = "AWS " & self.access-key-id & ":" & signature
    
    def url = {abs-url "http://" & self.headers["Host"] & key}
    
    || HTTP接続
    {return {open-http-file url, self.headers, verb}} 
  }
  
  || --------------------------------------------
  || delete-object
  {method public {delete-object
                     bucket:#String,
                     key:String
                 }:#HttpByteInputStream
    
    def verb = HttpRequestMethod.delete       
    
    set self.headers["Date"] = {convert-date}
    let string-to-sign:String = {self.return-string-to-sign bucket, key, verb}    
    def signature = {self.get-signature string-to-sign}
    set self.headers["Authorization"] = "AWS " & self.access-key-id & ":" & signature
    
    def url = {abs-url "http://" & self.headers["Host"] & key}
    
    || HTTP接続
    {return {open-http-file url, self.headers, verb}} 
  }
  
  || --------------------------------------------
  || head-object
  {method public {head-object
                     bucket:String,
                     key:String
                 }:#HttpByteInputStream
    
    def verb = HttpRequestMethod.head     
    
    set self.headers["Date"] = {convert-date}
    let string-to-sign:String = {self.return-string-to-sign bucket, key, verb}    
    def signature = {self.get-signature string-to-sign}
    set self.headers["Authorization"] = "AWS " & self.access-key-id & ":" & signature
    
    def url = {abs-url "http://" & self.headers["Host"] & key}
    
    || HTTP接続
    {return {open-http-file url, self.headers, verb}} 
  }
  
  ||---------------------------------------------
  || amz-headersに値を格納する
  || HttpRequestHeadersにも同様に格納する
  || 既にKeyが存在する場合、以前の値の末尾にコンマで繋げる
  {method public inline {set-amz-headers key:String, value:String}:void
    set self.headers[key]= value
    
    set key = {key.to-lower-clone}
    {if {self.amz-headers.key-exists? key} then
        set value = {self.amz-headers.get key} & "," & value
    }
    set self.amz-headers[key] = {key.to-lower-clone} & ":" & value
  }
  
  || amz-headersに存在するデータを取り出す
  {method public {get-all-amz-headers amz-headers:{HashTable-of String, String}}:String
    let ret:String = ""
    {for element:String in amz-headers do
        set ret = element & "\n" & ret
    }
    {return ret}
  }
  
  || amz-headersをリセットする
  {method public {reset-amz-headers}:void
    {self.amz-headers.clear}
  }
  
  {method private inline {return-string-to-sign
                             bucket:#String,
                             key:String,
                             verb:HttpRequestMethod,
                             headers:HttpRequestHeaders = self.headers,
                             amz-headers:{HashTable-of String, String} = self.amz-headers
                         }:String
    
    def resource =
        {value 
            {if-non-null bucket then
                set self.headers["Host"] = bucket & "." & self.default-host
                "/" & bucket & key 
             else
                set self.headers["Host"] = self.default-host
                key
            }
        }
    
    let string-to-sign:String = 
        {verb.name.to-upper-clone} & "\n" & 
    self.headers["Content-MD5"] & "\n" &
    self.headers["Content-Type"] & "\n" &
    self.headers["Date"] & "\n" &
    {self.get-all-amz-headers amz-headers} &
    resource
    
    {return string-to-sign}
  }
  
  {method private {get-signature string-to-sign:String}:String
    let sts:ByteVec = {ByteVec max-size = string-to-sign.size * CharEncoding.utf8.transcode-min-expansion-factor}
    
    {encode-characters string-to-sign, sts, CharEncoding.utf8}
    
    {return {base64-encode
                {{Array-of byte}.from-FastArray
                    {hex-decode
                        {hmac-sha-1
                            self.secret-key-id,
                            sts
                        }
                    }
                }
            }
    }
  }
}


|| レスポンスヘッダ取得用
||++{try
||++    let web-stream:HttpTextInputStream =
||++        {http-file.http-read-open
||++        }
||++    {for value:String key name:String in
||++                  web-stream.response-headers do
||++        {web-buffer.add {br}}
||++        {web-buffer.add name &
||++                      {if value == "" then
||++                          ""
||++                       else
||++                          ": " & value}
||++                  
||++        }
||++    }
||++    {web-stream.close}
||++    web-buffer
||++ catch
||++    err:HttpPermissionDeniedFileException do
||++    {text error: HttpPermissionDeniedFileException}
||++}