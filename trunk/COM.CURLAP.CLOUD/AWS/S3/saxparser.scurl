{curl-file-attributes character-encoding = "shift-jis"}

{import * from CURL.XML.SAX.BASE}
{import * from CURL.XML.SAX.PARSER}

{let package xr:XMLReader = {SAXParser}}

{define-proc public {parse-xml bis:#ByteInputStream}:void
    || clear the parse output of any previous xml file
    
    {let handler:SAX = {SAX}}
    {xr.set-content-handler handler}
    {xr.set-error-handler handler}
    
    {try
        || Parse from what is found by opening input-name
        {xr.parse {InputSource byte-stream = bis}}
        
     catch ex:IOException do
        || Handle any exception thrown due to the file read
        {throw ex}
     catch ex:SAXParseException do
        || Handle any exception thrown while parsing the XML
        {throw ex}
    }
}

{define-class public SAX {inherits DefaultHandler}

||  field public list-buckets:ListBucketInfo
  field public list-objects:{Array-of ObjectInfo}
  field private args-stack:{Array-of Arguments}
  field private sbuf:StringBuf
  
  {constructor public {default}
    {construct-super}
    set self.list-objects = {new {Array-of ObjectInfo}}
    set self.args-stack = {new {Array-of Arguments}, {Arguments}}
    set self.sbuf = {StringBuf}
  }
  
  {getter public {current-stack}:Arguments
    {return self.args-stack[self.args-stack.size - 1]}
  }
  
  {method public {start-document}:void
    
  }
  
  {method public {end-document}:void
  }
  
  {method public {start-element
                     uri:String,
                     name:String,
                     qname:String,
                     atts:Attributes
                 }:void

    {if name == "Error" then
        {self.s3-error {S3Exception "Error"}}
    }
    
    
  }
  
  {method public {end-element
                     uri:String,
                     name:String,
                     qname:String
                 }:void
  }
  
  {method public {characters
                     ch:StringBuf,
                     start:int,
                     length:int
                 }:void
    

  }
  
  {method public {error exception:SAXParseException}:void
    {throw exception}
  }
  
  {method public {fatal-error exception:SAXParseException}:void
    {throw exception}
  }
  
  {method public {warning exception:SAXParseException}:void
    {throw exception}
  }
 
  {method public {s3-error exception:S3Exception}:void
    {throw exception}
  }
  
}

{define-class public S3Exception {inherits Exception}
  field private code:String = ""
  
  {constructor public {default message:String}
    {construct-super message}
  }
}

{define-proc {error-message parse-exception:SAXParseException}:String
    let sb:StringBuf={StringBuf "Error detected"}
    {if {parse-exception.get-line-number} != 0
     then
        {sb.concat " at line " & {parse-exception.get-line-number}}
        {if {parse-exception.get-system-id} != null
         then
            {sb.concat " of " & {parse-exception.get-system-id}}
        }
    }
    {sb.concat ": " & {parse-exception.get-message}}
    {return {sb.to-String}}
}
