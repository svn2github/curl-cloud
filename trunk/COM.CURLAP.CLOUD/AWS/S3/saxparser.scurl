{curl-file-attributes character-encoding = "utf8"}

{define-class package ParseBuckets {inherits DefaultHandler}

  field package-get private-set list-bucket:{Array-of Arguments}
  field package-get private-set owner:Owner
  field private args-stack:{Array-of Arguments}
  field private sbuf:StringBuf
  
  {constructor package {default}
    {construct-super}
    set self.list-bucket = {new {Array-of Arguments}, {Arguments}}
    set self.owner = {uninitialized-value-for-type Owner}
    set self.args-stack = {new {Array-of Arguments}, {Arguments}}
    set self.sbuf = {StringBuf}
  }
  
  {getter private {current-stack}:Arguments
    {return self.args-stack[self.args-stack.size - 1]}
  }
  
  {method public {start-element
                     uri:String,
                     name:String,
                     qname:String,
                     atts:Attributes
                 }:void
    
    {self.sbuf.clear}
    {switch name
     case "ListAllMyBucketsResult" do
        {self.current-stack.clear}
     case "Owner" do
        {self.args-stack.append {Arguments}}
     case "Buckets" do
        {self.args-stack.append {Arguments}}
        {self.list-bucket.clear}
     case "Bucket" do
        {self.args-stack.append {Arguments}}
     case "Error" do
        {self.current-stack.clear}
    }   
  }
  
  {method public {end-element
                     uri:String,
                     name:String,
                     qname:String
                 }:void
    {switch name
     case "ListAllMyBucketsResult" do
        {self.current-stack.clear}
     case "Owner" do
        def owner-args = {self.args-stack.pop}
        |#{self.current-stack.append
            {Owner.from-xml {splice owner-args}},
            keyword = {name.to-lower-clone}
        }#|
        set self.owner = {Owner.from-xml {splice owner-args}}
     case "Buckets" do
        def buckets-args = {self.args-stack.pop}
        |#{self.current-stack.append
            self.list-bucket, keyword = {name.to-lower-clone}
        }#|
     case "Bucket" do
        |#
        def bucket-args = {self.args-stack.pop}
        {self.list-bucket.append
            {Bucket.from-xml {splice bucket-args}}
        }#|
        {self.list-bucket.append {self.args-stack.pop}}
     case "Error" do
        def ex-args = {self.args-stack.pop}
        let ex:S3Exception = {S3Exception.from-xml {splice ex-args}}
        {self.current-stack.clear}
        {throw ex}
     else
        {self.current-stack.append
            {self.sbuf.to-String},
            keyword = {name.to-lower-clone}
        }
        {self.sbuf.clear}
    } 
  }
  
  {method public {characters
                     ch:StringBuf,
                     start:int,
                     length:int
                 }:void
    {self.sbuf.concat ch}
  }
  
  {method public {s3-error exception:S3Exception}:void
    {throw exception}
  }
  
}

{define-class package ParseObjects {inherits DefaultHandler}
  
  field package-get private-set list-objects:{Array-of ObjectInfo}
  field package-get private-set args-stack:{Array-of Arguments}
  field private sbuf:StringBuf
  
  {constructor package {default}
    {construct-super}
    set self.list-objects = {new {Array-of ObjectInfo}}
    set self.args-stack = {new {Array-of Arguments}, {Arguments}}
    set self.sbuf = {StringBuf}
  }
  
  {getter private {current-stack}:Arguments
    {return self.args-stack[self.args-stack.size - 1]}
  }
  
  {method public {start-element
                     uri:String,
                     name:String,
                     qname:String,
                     atts:Attributes
                 }:void
    
    {self.sbuf.clear}
    {switch name
     case "Owner" do
        {self.args-stack.append {Arguments}}
     case "ListBucketResult" do
        {self.current-stack.clear}
     case"Contents" do
        {self.args-stack.append {Arguments}}
     case "Error" do
        {self.current-stack.clear}
    }   
  }
  
  {method public {end-element
                     uri:String,
                     name:String,
                     qname:String
                 }:void
    {switch name
     case "Owner" do
        def owner-args = {self.args-stack.pop}
        {self.current-stack.append
            {Owner.from-xml {splice owner-args}},
            keyword = {name.to-lower-clone}
        }
     case "ListBucketResult" do
        {self.current-stack.clear}
     case"Contents" do
        def contents-args = {self.args-stack.pop}
        {self.list-objects.append
            {ObjectInfo.from-xml {splice contents-args}}
        }
     case "Error" do
        def ex-args = {self.args-stack.pop}
        let ex:S3Exception = {S3Exception.from-xml {splice ex-args}}
        {self.current-stack.clear}
        {throw ex}
     else
        {self.current-stack.append
            {self.sbuf.to-String},
            keyword = {name.to-lower-clone}
        }
        {self.sbuf.clear}
    } 
  }
  
  {method public {characters
                     ch:StringBuf,
                     start:int,
                     length:int
                 }:void
    {self.sbuf.concat ch}
    
  }
  
  {method public {s3-error exception:S3Exception}:void
    {throw exception}
  }
  
}
{define-class public S3Exception {inherits Exception}
  field private code:String = ""
  
  {constructor public {default message:String}
    {construct-super message}
  }
  
  {factory public {from-xml message:String = "", ...}:S3Exception
    {return {S3Exception message}}
  }
}
