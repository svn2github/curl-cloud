{curl-file-attributes character-encoding = "utf8"}

|| ----------------------------------------------
|| S3に対してのリクエストを作成し送信するクラス
{define-class public S3Client
  
  || HTTPリクエストヘッダーに用いるハッシュテーブル
  field private headers:HttpRequestHeaders =
      {HttpRequestHeaders.default 
        "Host", "",
        "Date", ""
      }
  || x-amz headers
  field private amz-headers:{HashTable-of String, String} =
      {new {HashTable-of String, String}}
  field private default-host:String || ホスト初期値
  field private access-key-id:String
  field private secret-key-id:String
        
  || --------------------------------------------
  || コンストラクタ
  || (param)
  || access-key-id: Amazon S3にアクセスするためのアクセスキー
  || secret-key-id: Amazon S3の秘密鍵
  || default-host: 接続先ホストの初期値
  {constructor public {default access-key-id:String, secret-key-id:String, default-host:String}
    set self.access-key-id = access-key-id
    set self.secret-key-id = secret-key-id
    set self.default-host = default-host
    set self.headers["Host"] = self.default-host
  }
  
  || --------------------------------------------
  || get-bucket-list
  || バケットの一覧を取得する
  || (return)
  || 取得したバケット一覧
  {method public {get-bucket-list}:Buckets
    def verb = HttpRequestMethod.get
    let (signature:String, url:Url) = {self.return-signature-and-url null, "/", verb}
    
    {try
        {return {self.parse-bucket-xml {open-http-file url, self.headers, verb}}}
     catch ex:S3Exception do
        {throw ex}
    }
  }
  
  || --------------------------------------------
  || get-bucket
  || バケット内のオブジェクト一覧を取得する
  || (param)
  || bucket: 取得先のバケット名
  || key: 取得する際のオプション　(例：?acl, ?location)
  {method public {get-bucket bucket:String, key:String = "/"}:{Array-of ObjectInfo}
    def verb = HttpRequestMethod.get
    let (signature:String, url:Url) = {self.return-signature-and-url bucket, key, verb}
    
    {try
        {return {self.parse-object-xml {open-http-file url, self.headers, verb}}.list-objects}
     catch ex:S3Exception do
        {throw ex}
    }
  }
  
  || --------------------------------------------
  || get-object
  || オブジェクトを取得する
  || (param)
  || bucket: 取得先のバケット名
  || key: 取得したいオブジェクト名
  || (return)
  || 取得したオブジェクト
  {method public {get-object bucket:String, key:String}:HttpByteInputStream
    
    def verb = HttpRequestMethod.get
    let (signature:String, uri:Url) = {self.return-signature-and-url bucket, key, verb}
    
    def reply = {open-http-file uri, self.headers, verb}

    {return reply}
  }
 
  || --------------------------------------------
  || put-bucket
  || バケットを新規作成する
  || (param)
  || bucket: 作成したいバケット名
  || acl: バケットのアクセスコントロール
  {method public {put-bucket bucket:String, acl:#String = null}:void
    
    def verb = HttpRequestMethod.put
    
    {if-non-null acl then
        {self.set-amz-headers "x-amz-acl", acl}
    }
    let (signature:String, url:Url) = {self.return-signature-and-url bucket, "/", verb}
    
    {open-http-file url, self.headers, verb}
  }
  
||--  Bucketクラスに移動
||--  || --------------------------------------------
||--  || put-object
||--  {method public {put-object
||--                     bucket:#String,
||--                     key:String,
||--                     object:ByteArray,
||--                     acl:#String = null
||--                 }:void
||--    
||--    def content-type = {get-extension {url "." & key}}
||--    def verb = HttpRequestMethod.put      
||--    {if-non-null acl then
||--        {self.set-amz-headers "x-amz-acl", acl}
||--    }
||--    set self.headers["Content-Type"] = content-type
||--    let (signature:String, url:Url) = {self.return-signature-and-url bucket, key, verb}
||--    
||--    {open-http-file
||--        url,
||--        self.headers,
||--        verb,
||--        data = {ByteArrayHttpRequestData object}
||--    }
||--  }
||--  
||--  || --------------------------------------------
||--  || delete-bucket
||--  {method public {delete-bucket bucket:String}:void
||--    
||--    def verb = HttpRequestMethod.delete
||--    def key = "/"
||--    let (signature:String, url:Url) = {self.return-signature-and-url bucket, key, verb}
||--
||--    {open-http-file url, self.headers, verb}
||--  }

  || --------------------------------------------
  || delete-object
  {method public {delete-object bucket:String, key:String}:void
    def verb = HttpRequestMethod.delete
    let (signature:String, url:Url) = {self.return-signature-and-url bucket, key, verb}

    {open-http-file url, self.headers, verb}
  }
  
  || --------------------------------------------
  || head-object
  {method public {head-object bucket:String, key:String}:HttpByteInputStream
    
    def verb = HttpRequestMethod.head     
    let (signature:String, url:Url) = {self.return-signature-and-url bucket, key, verb}

    {return {open-http-file url, self.headers, verb}} 
  }
  
  ||---------------------------------------------
  || amz-headersに値を格納する
  || HttpRequestHeadersにも同様に格納する
  || 既にKeyが存在する場合、以前の値の末尾にコンマで繋げる
  {method package inline {set-amz-headers key:String, value:String}:void
    set self.headers[key]= value
    
    let value-buf:StringBuf = {StringBuf value}
    set key = {key.to-lower-clone}
    {if {self.amz-headers.key-exists? key} then
        set value = {self.amz-headers.get key} & "," & value
    }
    set self.amz-headers[key] = {key.to-lower-clone} & ":" & value
  }
  
  || amz-headersに存在するデータを取り出す
  {method package {get-all-amz-headers amz-headers:{HashTable-of String, String}}:String
    let ret:StringBuf = {StringBuf}
    {for element:String in amz-headers do
        {for c:char in element do
            {ret.append c}
        }
        {ret.append 0x000A} || \n
    }
    {return {ret.to-String}}
  }
  
  {method package {get-header-value key:String}:#String
    let value:#String = ""
    {if {self.headers.key-exists? key} then
        set value = self.headers[key]
    }
    {return value}
  }
  
  || headers に値を格納する
  || signature と RequestURL を返す
  {method package {return-signature-and-url bucket:#String, key:String, verb:HttpRequestMethod}:(String, Url)
    set self.headers["Date"] = {HttpHeaders.date-time-to-http-header-string {DateTime}}
    def resource =
        {value 
            {if-non-null bucket then
                set self.headers["Host"] = bucket & "." & self.default-host
                "/" & bucket & key 
             else
                set self.headers["Host"] = self.default-host
                key
            }
        }
    
    let string-to-sign:String = 
        {verb.name.to-upper-clone} & "\n" & 
        {self.get-header-value "Content-MD5"} & "\n" &
        {self.get-header-value "Content-Type"} & "\n" &
        {self.get-header-value "Date"} & "\n" &
        {self.get-all-amz-headers self.amz-headers} &
        resource
    
    let sts:ByteVec = {ByteVec max-size = string-to-sign.size * CharEncoding.utf8.transcode-min-expansion-factor}
    
    {encode-characters string-to-sign, sts, CharEncoding.utf8}

    def signature = {base64-encode
                        {{Array-of byte}.from-FastArray
                            {hex-decode
                                {hmac-sha-1
                                    self.secret-key-id,
                                    sts
                                }
                            }
                        }
                    }
    set self.headers["Authorization"] = "AWS " & self.access-key-id & ":" & signature
    def url = {abs-url "http://" & self.headers["Host"] & key}
    
    {return (signature, url)}
  }
  
  || --------------------------------------------
  || HTTPのリクエストに必要なHttpRequestHeaders
  {method package {get-headers}:HttpRequestHeaders
    {return self.headers}
  }
  
  {method package {set-headers key:String, value:String}:void
    set self.headers[key] = value
  }
  
  || --------------------------------------------
  || XML parser
  {method package {parse-bucket-xml bis:#ByteInputStream}:Buckets
    || clear the parse output of any previous xml file
    let xr:XMLReader = {SAXParser}
    let handler:ParseBuckets = {ParseBuckets}
    {xr.set-content-handler handler}
    {xr.set-error-handler handler}
    
    {try
        || Parse from what is found by opening input-name
        {xr.parse {InputSource byte-stream = bis}}
        let buckets:{Array-of Bucket} = {new {Array-of Bucket}}
        {for args:Arguments in handler.list-bucket do
            {buckets.append {Bucket.from-xml {splice args}, s3 = self}}
        }
        {return {Buckets handler.owner, buckets}}
     catch ex:IOException do
        || Handle any exception thrown due to the file read
        {throw ex}
     catch ex:SAXParseException do
        || Handle any exception thrown while parsing the XML
        {throw ex}
     catch ex:S3Exception do
        {throw ex}
    }
  }
  
  {method package {parse-object-xml bis:#ByteInputStream}:ParseObjects
    || clear the parse output of any previous xml file
    let xr:XMLReader = {SAXParser}
    {let handler:ParseObjects = {ParseObjects}}
    {xr.set-content-handler handler}
    {xr.set-error-handler handler}
    
    {try
        || Parse from what is found by opening input-name
        {xr.parse {InputSource byte-stream = bis}}
        {return handler} 
     catch ex:IOException do
        || Handle any exception thrown due to the file read
        {throw ex}
     catch ex:SAXParseException do
        || Handle any exception thrown while parsing the XML
        {throw ex}
     catch ex:S3Exception do
        {throw ex}
    }
  }
}
