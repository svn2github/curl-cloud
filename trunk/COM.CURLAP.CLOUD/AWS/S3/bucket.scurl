{curl-file-attributes character-encoding = "shift-jis"}
|| ----------------------------------------------
|| Bucket
{define-class public Bucket
  field public-get private-set name:String
  field public-get private-set creation-date:DateTime
  field private s3:S3Client
  
  {constructor package {default
                           name:String,
                           creation-date:DateTime,
                           s3:S3Client
                       }
    set self.name = name
    set self.creation-date = creation-date
    set self.s3 = s3
  }  
  
  {factory package {from-xml
                       name:String = "",
                       creationdate:String = "",
                       s3:S3Client = {S3Client "", ""},
                       ...
                   }:Bucket
    {return {Bucket name, {DateTime creationdate}, s3}}
  }
  
  || --------------------------------------------
  || Delete bucket
  {method public {delete-bucket}:void
    
    def verb = HttpRequestMethod.delete
    let uri:Url = {self.s3.return-signature-and-url self.name, "", verb}
    let reply:HttpByteInputStream = {uninitialized-value-for-type HttpByteInputStream}
    
    {try 
        set reply = {open-http-file uri, {self.s3.get-headers}, verb}
     catch ex:Exception do
        {throw ex}
     finally
        {reply.close}
        {self.s3.initialize-headers}
    }
  }
  
  || --------------------------------------------
  || delete-object
  {method public {delete-object key:String}:void
    def verb = HttpRequestMethod.delete
    let url:Url = {self.s3.return-signature-and-url self.name, key, verb}
    let reply:HttpByteInputStream = {uninitialized-value-for-type HttpByteInputStream}
    
    {try
        set reply = {open-http-file url, {self.s3.get-headers}, verb}
     catch ex:Exception do
        {throw ex}
     finally
        {reply.close}
        {self.s3.initialize-headers}
    }
  }
  
  || --------------------------------------------
  || Get list object in bucket
  || (param)
  || option: option (e.g. "?acl", "?location")
  || (return)
  || Object list
  {method public {get-bucket option:String = ""}:ObjectsInfo
    def verb = HttpRequestMethod.get
    let url:Url = {self.s3.return-signature-and-url self.name, option, verb}
    set url = {url.set-query "?prefix=&delimiter=/"}
    let reply:HttpByteInputStream = {uninitialized-value-for-type HttpByteInputStream}
    
    {try
        set reply = {open-http-file url, {self.s3.get-headers}, verb}
        {return {self.s3.parse-object-xml reply}}
     catch ex:Exception do
        {throw ex}
     finally
        {reply.close}
        {self.s3.initialize-headers}
    }
  }
  
  || --------------------------------------------
  || Get folder
  {method public {get-dir key:String}:ObjectsInfo
    def verb = HttpRequestMethod.get
    let url:Url = {self.s3.return-signature-and-url self.name, "", verb}
    set url = {url.set-query  "?prefix=" & key & "&delimiter=/"}
    let reply:HttpByteInputStream = {uninitialized-value-for-type HttpByteInputStream}
    
    {try
        set reply = {open-http-file url, {self.s3.get-headers}, verb}
        {return {self.s3.parse-object-xml reply}}
     catch ex:Exception do
        {throw ex}
     finally
        {reply.close}
        {self.s3.initialize-headers}
    }
  }
  
  || --------------------------------------------
  || Get object data
  || (param)
  || key: Object name
  || (return)
  || Object data
  {method public {get-object key:String}:HttpByteInputStream
    
    def verb = HttpRequestMethod.get
    let uri:Url = {self.s3.return-signature-and-url self.name, key, verb}
    let reply:HttpByteInputStream = {uninitialized-value-for-type HttpByteInputStream}
    
    {try
        set reply = {open-http-file uri, {self.s3.get-headers}, verb}
        {return reply}
     catch ex:Exception do
        {throw ex}
     finally
        {reply.close}
        {self.s3.initialize-headers}
    }
  }
  
  || --------------------------------------------
  || Put folder
  || (param)
  || key: folder name
  || acl: ACL@(e.g. "public-read")
  {method public {put-dir
                     key:String,
                     acl:#String = null
                 }:void
    
    def verb = HttpRequestMethod.put
    
    {if-non-null acl then
        {self.s3.set-amz-headers "x-amz-acl", acl}
    }
    set key = key & "/"
    let url:Url = {self.s3.return-signature-and-url self.name, key, verb}
    let reply:HttpByteInputStream = {uninitialized-value-for-type HttpByteInputStream}
    
    {try
        set reply = {open-http-file url, {self.s3.get-headers}, verb}
     catch ex:Exception do
        {throw ex}
     finally
        {reply.close}
        {self.s3.initialize-headers}
    }
  }
  
  || --------------------------------------------
  || Put object by bytes
  || (param)
  || key: object name
  || object: object data
  || acl: ACL@(e.g. "public-read")
  {method public {put-object-by-bytes
                     key:String,
                     object:ByteArray,
                     acl:#String = null
                 }:void
    
    def content-type = {file-extension-to-mime-type {url "./" & key}.extension}
    def verb = HttpRequestMethod.put
    
    {if-non-null acl then
        {self.s3.set-amz-headers "x-amz-acl", acl}
    }
    {if-non-null content-type then
        {self.s3.set-headers "Content-Type", content-type}
    }
    
    let url:Url = {self.s3.return-signature-and-url self.name, key, verb}
    let reply:HttpByteInputStream = {uninitialized-value-for-type HttpByteInputStream}
    
    {try
        set reply = {open-http-file
                        url,
                        {self.s3.get-headers},
                        verb,
                        data = {ByteArrayHttpRequestData object}
                    }
     catch ex:Exception do
        {throw ex}
     finally
        {reply.close}
        {self.s3.initialize-headers}
    }
  }
  
  || --------------------------------------------
  || Put object by URL (file path)
  || (param)
  || key: object name
  || uri: file path
  || acl: ACL@(e.g. "public-read")
  {method public {put-object-by-url
                     key:String,
                     uri:Url,
                     acl:#String = null
                 }:void
    
    def content-type = {file-extension-to-mime-type {url "./" & key}.extension}
    def verb = HttpRequestMethod.put
    
    {if-non-null acl then
        {self.s3.set-amz-headers "x-amz-acl", acl}
    }
    {if-non-null content-type then
        {self.s3.set-headers "Content-Type", content-type}
    }
    
    let url:Url = {self.s3.return-signature-and-url self.name, key, verb}
    let reply:HttpByteInputStream = {uninitialized-value-for-type HttpByteInputStream}
    
    {try
        def data = {open-byte-file uri}
        set reply = {open-http-file
                        url,
                        {self.s3.get-headers},
                        verb,
                        data = {ByteArrayHttpRequestData data}
                    }
     catch ex:Exception do
        {throw ex}
     finally
        {reply.close}
        {self.s3.initialize-headers}
    }
  }
  
  || --------------------------------------------
  || Write object to file
  {method package {write-file hbis:HttpByteInputStream, uri:Url}:void
    {with-open-streams bos:ByteOutputStream = {write-open-byte uri} do
        {bos.write {{{ByteInputStream-from {Array-of byte}} {hbis.read}}.read}}
        {bos.flush}
    }
  }
}

|| ----------------------------------------------
|| Bucket list
{define-class public Buckets
  field public-get private-set owner:Owner
  field public-get private-set buckets:{Array-of Bucket}
  
  {constructor package {default
                          owner:Owner,
                          buckets:{Array-of Bucket}
                      }
    set self.owner = owner
    set self.buckets = buckets
  }
  
  {factory package {from-xml
                       owner:Owner = {Owner "id", "name"},
                       buckets:{Array-of Bucket} = {new {Array-of Bucket}},
                       ...
                   }:Buckets
    {return {Buckets owner, buckets}}
  }
  
  {method public {find key:String}:{Array-of Bucket}
    let ret:{Array-of Bucket} = {new {Array-of Bucket}}
    {for b:Bucket in self.buckets do
        {if {b.name.find-string key} >= 0 then
            {ret.append b}
        }
    }
    {return ret}
  }
}